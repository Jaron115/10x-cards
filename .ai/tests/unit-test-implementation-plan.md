# Unit Test Implementation - Plan dla pozosta≈Çych etap√≥w

## üìã Overview

Ten dokument opisuje plan implementacji test√≥w jednostkowych dla pozosta≈Çych komponent√≥w funkcjonalno≈õci Generator AI w aplikacji 10x-cards.

**Status:** üìù Planowanie  
**Priorytet:** ≈öredni/Niski (logika biznesowa ju≈º pokryta)  
**Szacowany czas:** 2-3 godziny

---

## üéØ Strategia testowania

### Podzia≈Ç priorytet√≥w

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  PRIORYTET TESTOWANIA                                       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚úÖ KRYTYCZNY   - Logika biznesowa (DONE)                   ‚îÇ
‚îÇ  üü° WYSOKI      - Edycja + walidacja UI                     ‚îÇ
‚îÇ  üü¢ ≈öREDNI      - Prezentacja i formatowanie                ‚îÇ
‚îÇ  üîµ NISKI       - Integration tests (nice to have)          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Filozofia testowania UI

**Testujemy:**

- ‚úÖ Logikƒô w komponentach (walidacja, warunkowe renderowanie)
- ‚úÖ Interakcje u≈ºytkownika (clicks, input changes)
- ‚úÖ Efekty uboczne (callbacks, API calls)

**NIE testujemy:**

- ‚ùå Styl√≥w i uk≈Çadu (lepsze dla visual regression tests)
- ‚ùå Bibliotek third-party (shadcn/ui)
- ‚ùå Prostych prezenter√≥w bez logiki

---

## üéØ ETAP 2: FlashcardProposalCard.tsx

**Plik do utworzenia:** `tests/unit/components/generator/FlashcardProposalCard.test.tsx`  
**Szacowana liczba test√≥w:** 10-12 test√≥w  
**Priorytet:** üü° Wysoki  
**Czas realizacji:** ~45-60 minut

### Dlaczego wysoki priorytet?

- Zawiera logikƒô edycji inline
- Walidacja formularza (limity znak√≥w)
- ZarzƒÖdzanie stanem lokalnym (tryb edycji)
- Z≈Ço≈ºone interakcje u≈ºytkownika

### Komponent overview

```typescript
interface FlashcardProposalCardProps {
  proposal: FlashcardProposalViewModel;
  onUpdateProposal: (updatedProposal: FlashcardProposalViewModel) => void;
  onSetProposalStatus: (id: string, status: "pending" | "approved" | "rejected") => void;
}
```

**Stan lokalny:**

- `isEditing: boolean`
- `editedFront: string`
- `editedBack: string`

**Walidacja:**

- MAX_FRONT_CHARS = 200
- MAX_BACK_CHARS = 500

---

### KROK 2.1: Renderowanie i stan poczƒÖtkowy (3 testy)

#### Test 1: Renderowanie podstawowe

```typescript
it("powinien renderowaƒá front i back w trybie read-only", () => {
  // Arrange
  const mockProposal = {
    id: "123-0",
    front: "Pytanie testowe",
    back: "Odpowied≈∫ testowa",
    status: "pending",
    source: "ai-full",
  };

  // Act
  render(<FlashcardProposalCard proposal={mockProposal} onUpdateProposal={vi.fn()} onSetProposalStatus={vi.fn()} />);

  // Assert
  expect(screen.getByText("Pytanie testowe")).toBeInTheDocument();
  expect(screen.getByText("Odpowied≈∫ testowa")).toBeInTheDocument();
  expect(screen.queryByRole("textbox")).not.toBeInTheDocument(); // Nie ma textarea
});
```

**Sprawdza:**

- Wy≈õwietlanie `proposal.front` i `proposal.back`
- Brak textarea w trybie read-only
- Struktura HTML

#### Test 2: Badge dla ≈∫r√≥d≈Ça

```typescript
it('powinien pokazaƒá badge "Wygenerowane" dla source=ai-full', () => {
  const mockProposal = { ...baseProposal, source: "ai-full" };
  render(<FlashcardProposalCard {...props} proposal={mockProposal} />);

  expect(screen.getByText("Wygenerowane")).toBeInTheDocument();
});

it('powinien pokazaƒá badge "Edytowane" dla source=ai-edited', () => {
  const mockProposal = { ...baseProposal, source: "ai-edited" };
  render(<FlashcardProposalCard {...props} proposal={mockProposal} />);

  expect(screen.getByText("Edytowane")).toBeInTheDocument();
});
```

**Sprawdza:**

- Warunki renderowania badge
- Tekst w badge

#### Test 3: Style dla status√≥w

```typescript
it("powinien zastosowaƒá zielone style dla approved", () => {
  const mockProposal = { ...baseProposal, status: "approved" };
  const { container } = render(<FlashcardProposalCard {...props} proposal={mockProposal} />);

  const card = container.querySelector(".border-green-500");
  expect(card).toBeInTheDocument();
});

it("powinien zastosowaƒá opacity i grayscale dla rejected", () => {
  const mockProposal = { ...baseProposal, status: "rejected" };
  const { container } = render(<FlashcardProposalCard {...props} proposal={mockProposal} />);

  const card = container.querySelector(".opacity-50");
  expect(card).toBeInTheDocument();
});
```

**Sprawdza:**

- Conditional className dla approved
- Conditional className dla rejected
- U≈ºycie `cn()` utility

---

### KROK 2.2: Tryb edycji (4 testy)

#### Test 1: W≈ÇƒÖczenie trybu edycji

```typescript
it("powinien prze≈ÇƒÖczyƒá siƒô w tryb edycji po klikniƒôciu przycisku ‚úèÔ∏è", async () => {
  render(<FlashcardProposalCard {...props} proposal={mockProposal} />);

  const editButton = screen.getByTitle("Edytuj");
  await userEvent.click(editButton);

  // Assert - textarea sƒÖ widoczne
  const textareas = screen.getAllByRole("textbox");
  expect(textareas).toHaveLength(2); // Front + Back

  // Assert - przyciski edycji widoczne
  expect(screen.getByTitle("Zapisz")).toBeInTheDocument();
  expect(screen.getByTitle("Anuluj")).toBeInTheDocument();

  // Assert - przyciski approve/reject ukryte
  expect(screen.queryByTitle("Zatwierd≈∫")).not.toBeInTheDocument();
});
```

**Sprawdza:**

- Toggle `isEditing` state
- Conditional rendering textarea
- Zmiana przycisk√≥w

#### Test 2: Liczniki znak√≥w

```typescript
it("powinien pokazaƒá liczniki znak√≥w w trybie edycji", async () => {
  const mockProposal = {
    ...baseProposal,
    front: "Test", // 4 znaki
    back: "Answer test", // 11 znak√≥w
  };

  render(<FlashcardProposalCard {...props} proposal={mockProposal} />);

  await userEvent.click(screen.getByTitle("Edytuj"));

  expect(screen.getByText("4 / 200 znak√≥w")).toBeInTheDocument();
  expect(screen.getByText("11 / 500 znak√≥w")).toBeInTheDocument();
});
```

**Sprawdza:**

- Wy≈õwietlanie licznika
- Format: "X / MAX znak√≥w"

#### Test 3: Walidacja d≈Çugo≈õci

```typescript
it("powinien wy≈õwietliƒá czerwony border gdy front > 200 znak√≥w", async () => {
  render(<FlashcardProposalCard {...props} proposal={mockProposal} />);

  await userEvent.click(screen.getByTitle("Edytuj"));

  const frontTextarea = screen.getAllByRole("textbox")[0];
  await userEvent.clear(frontTextarea);
  await userEvent.type(frontTextarea, "a".repeat(201));

  expect(frontTextarea).toHaveClass("border-destructive");
});

it("powinien zablokowaƒá przycisk Zapisz gdy walidacja nie przechodzi", async () => {
  render(<FlashcardProposalCard {...props} proposal={mockProposal} />);

  await userEvent.click(screen.getByTitle("Edytuj"));

  const frontTextarea = screen.getAllByRole("textbox")[0];
  await userEvent.clear(frontTextarea); // Pusty front (invalid)

  expect(screen.getByTitle("Zapisz")).toBeDisabled();
});
```

**Sprawdza:**

- Walidacja min (> 0) i max (‚â§ 200/500)
- `isFrontValid` i `isBackValid`
- `canSave` computed value
- Disabled state przycisku

#### Test 4: Anulowanie edycji

```typescript
it("powinien przywr√≥ciƒá oryginalne warto≈õci po anulowaniu", async () => {
  const mockProposal = {
    ...baseProposal,
    front: "Original front",
    back: "Original back",
  };

  render(<FlashcardProposalCard {...props} proposal={mockProposal} />);

  // Enter edit mode
  await userEvent.click(screen.getByTitle("Edytuj"));

  // Change values
  const frontTextarea = screen.getAllByRole("textbox")[0];
  await userEvent.clear(frontTextarea);
  await userEvent.type(frontTextarea, "Changed front");

  // Cancel
  await userEvent.click(screen.getByTitle("Anuluj"));

  // Assert - original values restored
  expect(screen.getByText("Original front")).toBeInTheDocument();
  expect(screen.queryByRole("textbox")).not.toBeInTheDocument(); // Exit edit mode
});
```

**Sprawdza:**

- `handleCancelEdit()`
- Reset `editedFront` i `editedBack`
- Wyj≈õcie z trybu edycji

---

### KROK 2.3: Zatwierdzanie i odrzucanie (3 testy)

#### Test 1: Approve toggle

```typescript
it("powinien zmieniƒá status z pending na approved po klikniƒôciu ‚úì", async () => {
  const mockSetStatus = vi.fn();

  render(<FlashcardProposalCard {...props} onSetProposalStatus={mockSetStatus} />);

  const approveButton = screen.getByTitle("Zatwierd≈∫");
  await userEvent.click(approveButton);

  expect(mockSetStatus).toHaveBeenCalledWith("123-0", "approved");
});

it("powinien zmieniƒá status z approved na pending po ponownym klikniƒôciu ‚úì", async () => {
  const mockProposal = { ...baseProposal, status: "approved" };
  const mockSetStatus = vi.fn();

  render(<FlashcardProposalCard {...props} proposal={mockProposal} onSetProposalStatus={mockSetStatus} />);

  const approveButton = screen.getByTitle("Cofnij zatwierdzenie");
  await userEvent.click(approveButton);

  expect(mockSetStatus).toHaveBeenCalledWith("123-0", "pending");
});
```

**Sprawdza:**

- `handleApprove()` logic
- Toggle behavior: `isApproved ? "pending" : "approved"`
- Zmiana tytu≈Çu przycisku

#### Test 2: Reject toggle

```typescript
it("powinien zmieniƒá status z pending na rejected po klikniƒôciu üóëÔ∏è", async () => {
  const mockSetStatus = vi.fn();

  render(<FlashcardProposalCard {...props} onSetProposalStatus={mockSetStatus} />);

  const rejectButton = screen.getByTitle("Odrzuƒá");
  await userEvent.click(rejectButton);

  expect(mockSetStatus).toHaveBeenCalledWith("123-0", "rejected");
});
```

**Sprawdza:**

- `handleReject()` logic
- Toggle behavior: `isRejected ? "pending" : "rejected"`

#### Test 3: Przyciski w trybie edycji

```typescript
it("nie powinien pokazaƒá przycisk√≥w approve/reject w trybie edycji", async () => {
  render(<FlashcardProposalCard {...props} />);

  await userEvent.click(screen.getByTitle("Edytuj"));

  expect(screen.queryByTitle("Zatwierd≈∫")).not.toBeInTheDocument();
  expect(screen.queryByTitle("Odrzuƒá")).not.toBeInTheDocument();
});
```

**Sprawdza:**

- Conditional rendering: `!isEditing && <ApproveButton />`

---

### KROK 2.4: Zapisywanie edycji (2 testy)

#### Test 1: Sukces zapisu

```typescript
it("powinien wywo≈Çaƒá onUpdateProposal z zaktualizowanymi danymi", async () => {
  const mockUpdate = vi.fn();

  render(<FlashcardProposalCard {...props} onUpdateProposal={mockUpdate} />);

  // Enter edit mode
  await userEvent.click(screen.getByTitle("Edytuj"));

  // Edit
  const frontTextarea = screen.getAllByRole("textbox")[0];
  await userEvent.clear(frontTextarea);
  await userEvent.type(frontTextarea, "New front");

  const backTextarea = screen.getAllByRole("textbox")[1];
  await userEvent.clear(backTextarea);
  await userEvent.type(backTextarea, "New back");

  // Save
  await userEvent.click(screen.getByTitle("Zapisz"));

  // Assert
  expect(mockUpdate).toHaveBeenCalledWith({
    id: "123-0",
    front: "New front",
    back: "New back",
    source: "ai-edited",
    status: "approved", // Auto-approve!
  });
});
```

**Sprawdza:**

- `handleSaveEdit()` logic
- Aktualizacja `front` i `back`
- Zmiana `source` ‚Üí "ai-edited"
- Auto-approve: `status: "approved"`
- Wyj≈õcie z trybu edycji

#### Test 2: Wyj≈õcie z trybu edycji

```typescript
it("powinien wyj≈õƒá z trybu edycji po zapisaniu", async () => {
  render(<FlashcardProposalCard {...props} />);

  await userEvent.click(screen.getByTitle("Edytuj"));
  expect(screen.getAllByRole("textbox")).toHaveLength(2);

  await userEvent.click(screen.getByTitle("Zapisz"));

  expect(screen.queryByRole("textbox")).not.toBeInTheDocument();
});
```

**Sprawdza:**

- `setIsEditing(false)` po zapisie

---

### Setup i mocki dla ETAPU 2

```typescript
// FlashcardProposalCard.test.tsx
import { describe, it, expect, vi, beforeEach } from "vitest";
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { FlashcardProposalCard } from "@/components/generator/FlashcardProposalCard";
import type { FlashcardProposalViewModel } from "@/types";

// Mock cn utility
vi.mock("@/lib/utils", () => ({
  cn: vi.fn((...args: any[]) => args.filter(Boolean).join(" ")),
}));

describe("FlashcardProposalCard", () => {
  const baseProposal: FlashcardProposalViewModel = {
    id: "123-0",
    front: "Test question",
    back: "Test answer",
    status: "pending",
    source: "ai-full",
  };

  const defaultProps = {
    proposal: baseProposal,
    onUpdateProposal: vi.fn(),
    onSetProposalStatus: vi.fn(),
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  // Testy tutaj...
});
```

---

## üéØ ETAP 3: GenerationForm.tsx

**Plik do utworzenia:** `tests/unit/components/generator/GenerationForm.test.tsx`  
**Szacowana liczba test√≥w:** 8-10 test√≥w  
**Priorytet:** üü° Wysoki  
**Czas realizacji:** ~30-45 minut

### Dlaczego wysoki priorytet?

- Walidacja UI (kolorowanie licznika)
- Komunikaty walidacyjne dla u≈ºytkownika
- Conditional rendering
- Event handling

### Komponent overview

```typescript
interface GenerationFormProps {
  sourceText: string;
  onSourceTextChange: (text: string) => void;
  onGenerate: () => void;
  isLoading: boolean;
  characterCount: number;
  isTextValid: boolean;
}

const MIN_CHARS = 1000;
const MAX_CHARS = 10000;
```

**Funkcje do przetestowania:**

- `getCharacterCountColor()` - logika kolorowania
- `handleSubmit()` - walidacja przed submit
- Conditional rendering komunikat√≥w

---

### KROK 3.1: Renderowanie element√≥w (2 testy)

#### Test 1: Podstawowe elementy

```typescript
it("powinien renderowaƒá wszystkie kluczowe elementy formularza", () => {
  render(<GenerationForm {...defaultProps} />);

  expect(screen.getByPlaceholderText(/Wklej tutaj tekst/i)).toBeInTheDocument();
  expect(screen.getByText(/Generuj fiszki/i)).toBeInTheDocument();
  expect(screen.getByText(/10,000 znak√≥w/i)).toBeInTheDocument();
});
```

#### Test 2: Struktura HTML

```typescript
it("powinien mieƒá prawid≈ÇowƒÖ strukturƒô Card", () => {
  const { container } = render(<GenerationForm {...defaultProps} />);

  expect(container.querySelector("form")).toBeInTheDocument();
  expect(screen.getByRole("textbox")).toBeInTheDocument();
  expect(screen.getByRole("button", { name: /Generuj/i })).toBeInTheDocument();
});
```

---

### KROK 3.2: Kolorowanie licznika (3 testy)

#### Test 1: Szary dla < MIN_CHARS

```typescript
it("powinien pokazaƒá szary kolor licznika gdy < 1000 znak√≥w", () => {
  render(<GenerationForm {...defaultProps} characterCount={500} isTextValid={false} />);

  const counter = screen.getByText(/500/);
  expect(counter).toHaveClass("text-muted-foreground");
});
```

#### Test 2: Zielony dla zakresu prawid≈Çowego

```typescript
it("powinien pokazaƒá zielony kolor licznika gdy 1000-10000 znak√≥w", () => {
  render(<GenerationForm {...defaultProps} characterCount={5000} isTextValid={true} />);

  const counter = screen.getByText(/5,000/);
  expect(counter).toHaveClass("text-green-600");
});
```

#### Test 3: Czerwony dla > MAX_CHARS

```typescript
it("powinien pokazaƒá czerwony kolor licznika gdy > 10000 znak√≥w", () => {
  render(<GenerationForm {...defaultProps} characterCount={15000} isTextValid={false} />);

  const counter = screen.getByText(/15,000/);
  expect(counter).toHaveClass("text-destructive");
});
```

**Sprawdza:**

- `getCharacterCountColor()` logic
- Conditional className

---

### KROK 3.3: Komunikaty walidacyjne (3 testy)

#### Test 1: Komunikat minimum

```typescript
it('powinien pokazaƒá "Minimum: 1,000 znak√≥w" gdy 0 < chars < 1000', () => {
  render(<GenerationForm {...defaultProps} characterCount={500} />);

  expect(screen.getByText(/Minimum: 1,000 znak√≥w/i)).toBeInTheDocument();
});

it("nie powinien pokazaƒá komunikatu minimum gdy characterCount = 0", () => {
  render(<GenerationForm {...defaultProps} characterCount={0} />);

  expect(screen.queryByText(/Minimum:/i)).not.toBeInTheDocument();
});
```

#### Test 2: Komunikat przekroczenia

```typescript
it("powinien pokazaƒá komunikat przekroczenia gdy > 10000 znak√≥w", () => {
  render(<GenerationForm {...defaultProps} characterCount={10500} />);

  expect(screen.getByText(/Przekroczono limit o 500 znak√≥w/i)).toBeInTheDocument();
});
```

#### Test 3: Brak komunikatu w prawid≈Çowym zakresie

```typescript
it("nie powinien pokazaƒá ≈ºadnego komunikatu gdy tekst prawid≈Çowy", () => {
  render(<GenerationForm {...defaultProps} characterCount={5000} isTextValid={true} />);

  expect(screen.queryByText(/Minimum:/i)).not.toBeInTheDocument();
  expect(screen.queryByText(/Przekroczono/i)).not.toBeInTheDocument();
});
```

**Sprawdza:**

- Conditional rendering komunikat√≥w
- Obliczenia: `characterCount - MAX_CHARS`

---

### KROK 3.4: Stan formularza i interakcje (2 testy)

#### Test 1: Disabled states

```typescript
it("powinien zablokowaƒá przycisk gdy !isTextValid", () => {
  render(<GenerationForm {...defaultProps} isTextValid={false} />);

  expect(screen.getByRole("button", { name: /Generuj/i })).toBeDisabled();
});

it("powinien zablokowaƒá przycisk i textarea podczas ≈Çadowania", () => {
  render(<GenerationForm {...defaultProps} isLoading={true} />);

  expect(screen.getByRole("button", { name: /Generowanie/i })).toBeDisabled();
  expect(screen.getByRole("textbox")).toBeDisabled();
});
```

#### Test 2: Event handling

```typescript
it("powinien wywo≈Çaƒá onSourceTextChange przy zmianie tekstu", async () => {
  const mockOnChange = vi.fn();

  render(<GenerationForm {...defaultProps} onSourceTextChange={mockOnChange} />);

  const textarea = screen.getByRole("textbox");
  await userEvent.type(textarea, "Test text");

  expect(mockOnChange).toHaveBeenCalled();
});

it("powinien wywo≈Çaƒá onGenerate przy submit gdy isTextValid=true", async () => {
  const mockOnGenerate = vi.fn();

  render(<GenerationForm {...defaultProps} isTextValid={true} onGenerate={mockOnGenerate} />);

  const button = screen.getByRole("button", { name: /Generuj/i });
  await userEvent.click(button);

  expect(mockOnGenerate).toHaveBeenCalled();
});

it("nie powinien wywo≈Çaƒá onGenerate gdy isTextValid=false", async () => {
  const mockOnGenerate = vi.fn();

  render(<GenerationForm {...defaultProps} isTextValid={false} onGenerate={mockOnGenerate} />);

  // Button is disabled, but test the form submit too
  const form = screen.getByRole("textbox").closest("form")!;
  await userEvent.click(form); // Try to submit

  expect(mockOnGenerate).not.toHaveBeenCalled();
});
```

**Sprawdza:**

- `handleSubmit()` logic
- `e.preventDefault()`
- Event callbacks

---

### Setup dla ETAPU 3

```typescript
import { describe, it, expect, vi } from "vitest";
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { GenerationForm } from "@/components/generator/GenerationForm";

describe("GenerationForm", () => {
  const defaultProps = {
    sourceText: "",
    onSourceTextChange: vi.fn(),
    onGenerate: vi.fn(),
    isLoading: false,
    characterCount: 0,
    isTextValid: false,
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  // Testy tutaj...
});
```

---

## üéØ ETAP 4: FlashcardProposalList.tsx

**Plik do utworzenia:** `tests/unit/components/generator/FlashcardProposalList.test.tsx`  
**Szacowana liczba test√≥w:** 6-8 test√≥w  
**Priorytet:** üü¢ ≈öredni  
**Czas realizacji:** ~30-40 minut

### Dlaczego ≈õredni priorytet?

- G≈Ç√≥wnie prezentacyjny komponent
- Prosta logika warunkowa
- Formatowanie tekstu (pluralizacja)

### Komponent overview

```typescript
interface FlashcardProposalListProps {
  proposals: FlashcardProposalViewModel[];
  isLoading: boolean;
  isSaving: boolean;
  onUpdateProposal: (updatedProposal: FlashcardProposalViewModel) => void;
  onSetProposalStatus: (id: string, status: FlashcardProposalViewModel["status"]) => void;
  onSave: () => void;
  approvedCount: number;
}
```

---

### KROK 4.1: Renderowanie warunkowe (3 testy)

#### Test 1: Loading state

```typescript
it("powinien pokazaƒá 6 skeleton√≥w podczas ≈Çadowania", () => {
  render(<FlashcardProposalList {...defaultProps} isLoading={true} proposals={[]} />);

  expect(screen.getByText("Generowanie propozycji...")).toBeInTheDocument();

  const skeletons = document.querySelectorAll(".animate-pulse");
  expect(skeletons.length).toBeGreaterThanOrEqual(6);
});
```

#### Test 2: Empty state

```typescript
it("nie powinien renderowaƒá nic gdy proposals=[] i !isLoading", () => {
  const { container } = render(<FlashcardProposalList {...defaultProps} proposals={[]} isLoading={false} />);

  expect(container.textContent).toBe("");
});
```

#### Test 3: Lista propozycji

```typescript
it("powinien renderowaƒá listƒô gdy proposals.length > 0", () => {
  const mockProposals = [
    { id: "1-0", front: "Q1", back: "A1", status: "pending", source: "ai-full" },
    { id: "1-1", front: "Q2", back: "A2", status: "pending", source: "ai-full" },
  ];

  render(<FlashcardProposalList {...defaultProps} proposals={mockProposals} />);

  expect(screen.getByText("Propozycje fiszek")).toBeInTheDocument();
  expect(screen.getByText(/Wygenerowano 2/)).toBeInTheDocument();
});
```

---

### KROK 4.2: Wy≈õwietlanie informacji (3 testy)

#### Test 1: Pluralizacja

```typescript
it('powinien u≈ºyƒá "fiszkƒô" dla liczby pojedynczej', () => {
  const mockProposals = [{ id: "1-0", front: "Q1", back: "A1", status: "pending", source: "ai-full" }];

  render(<FlashcardProposalList {...defaultProps} proposals={mockProposals} />);

  expect(screen.getByText(/Wygenerowano 1 fiszkƒô/)).toBeInTheDocument();
});

it('powinien u≈ºyƒá "fiszek" dla liczby mnogiej', () => {
  const mockProposals = [
    { id: "1-0", front: "Q1", back: "A1", status: "pending", source: "ai-full" },
    { id: "1-1", front: "Q2", back: "A2", status: "pending", source: "ai-full" },
  ];

  render(<FlashcardProposalList {...defaultProps} proposals={mockProposals} />);

  expect(screen.getByText(/Wygenerowano 2 fiszek/)).toBeInTheDocument();
});
```

#### Test 2: Licznik zatwierdzonych

```typescript
it("powinien pokazaƒá licznik zatwierdzonych gdy approvedCount > 0", () => {
  const mockProposals = [
    { id: "1-0", front: "Q1", back: "A1", status: "approved", source: "ai-full" },
    { id: "1-1", front: "Q2", back: "A2", status: "pending", source: "ai-full" },
  ];

  render(<FlashcardProposalList {...defaultProps} proposals={mockProposals} approvedCount={1} />);

  expect(screen.getByText(/Zatwierdzono: 1/)).toBeInTheDocument();
});

it("nie powinien pokazaƒá licznika gdy approvedCount = 0", () => {
  const mockProposals = [{ id: "1-0", front: "Q1", back: "A1", status: "pending", source: "ai-full" }];

  render(<FlashcardProposalList {...defaultProps} proposals={mockProposals} approvedCount={0} />);

  expect(screen.queryByText(/Zatwierdzono:/)).not.toBeInTheDocument();
});
```

---

### KROK 4.3: Przyciski zapisywania (2 testy)

#### Test 1: Ukrywanie przycisk√≥w

```typescript
it("nie powinien pokazaƒá przycisk√≥w Zapisz gdy approvedCount = 0", () => {
  const mockProposals = [{ id: "1-0", front: "Q1", back: "A1", status: "pending", source: "ai-full" }];

  render(<FlashcardProposalList {...defaultProps} proposals={mockProposals} approvedCount={0} />);

  expect(screen.queryByRole("button", { name: /Zapisz/i })).not.toBeInTheDocument();
});
```

#### Test 2: Pokazywanie przycisk√≥w

```typescript
it("powinien pokazaƒá 2 przyciski Zapisz gdy approvedCount > 0", () => {
  const mockProposals = [{ id: "1-0", front: "Q1", back: "A1", status: "approved", source: "ai-full" }];

  render(<FlashcardProposalList {...defaultProps} proposals={mockProposals} approvedCount={1} />);

  const saveButtons = screen.getAllByRole("button", { name: /Zapisz fiszki \(1\)/i });
  expect(saveButtons).toHaveLength(2); // G√≥ra + d√≥≈Ç
});

it("powinien pokazaƒá Zapisywanie... podczas isSaving", () => {
  const mockProposals = [{ id: "1-0", front: "Q1", back: "A1", status: "approved", source: "ai-full" }];

  render(<FlashcardProposalList {...defaultProps} proposals={mockProposals} approvedCount={1} isSaving={true} />);

  expect(screen.getAllByText(/Zapisywanie.../i)).toHaveLength(2);
});

it("powinien wywo≈Çaƒá onSave po klikniƒôciu przycisku", async () => {
  const mockOnSave = vi.fn();
  const mockProposals = [{ id: "1-0", front: "Q1", back: "A1", status: "approved", source: "ai-full" }];

  render(<FlashcardProposalList {...defaultProps} proposals={mockProposals} approvedCount={1} onSave={mockOnSave} />);

  const saveButton = screen.getAllByRole("button", { name: /Zapisz/i })[0];
  await userEvent.click(saveButton);

  expect(mockOnSave).toHaveBeenCalledTimes(1);
});
```

---

### Setup dla ETAPU 4

```typescript
import { describe, it, expect, vi } from "vitest";
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { FlashcardProposalList } from "@/components/generator/FlashcardProposalList";

// Mock child component
vi.mock("@/components/generator/FlashcardProposalCard", () => ({
  FlashcardProposalCard: ({ proposal }: any) => <div data-testid={`proposal-${proposal.id}`}>{proposal.front}</div>,
}));

describe("FlashcardProposalList", () => {
  const defaultProps = {
    proposals: [],
    isLoading: false,
    isSaving: false,
    onUpdateProposal: vi.fn(),
    onSetProposalStatus: vi.fn(),
    onSave: vi.fn(),
    approvedCount: 0,
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  // Testy tutaj...
});
```

---

## üéØ ETAP 5: Integration Tests (Opcjonalny)

**Plik do utworzenia:** `tests/unit/components/generator/Generator.integration.test.tsx`  
**Szacowana liczba test√≥w:** 2-3 testy  
**Priorytet:** üîµ Niski (nice to have)  
**Czas realizacji:** ~30-45 minut

### Dlaczego niski priorytet?

- Pe≈Çny flow lepiej testowaƒá w E2E
- Jednostki ju≈º pokryte
- Wysokie koszty utrzymania

### Co testowaƒá?

#### Test: Pe≈Çny flow u≈ºytkownika

```typescript
it("powinien wykonaƒá pe≈Çny flow: generuj ‚Üí edytuj ‚Üí zatwierd≈∫ ‚Üí zapisz", async () => {
  // Mock API responses
  const mockGenerateResponse = { /* ... */ };
  const mockSaveResponse = { /* ... */ };

  // Render full component tree
  render(<GeneratorView />);

  // 1. Wpisz tekst
  const textarea = screen.getByPlaceholderText(/Wklej tutaj/i);
  await userEvent.type(textarea, "a".repeat(2000));

  // 2. Generuj
  await userEvent.click(screen.getByRole("button", { name: /Generuj/i }));
  await waitFor(() => expect(screen.getByText(/Propozycje fiszek/i)).toBeInTheDocument());

  // 3. Edytuj pierwszƒÖ fiszkƒô
  const editButtons = screen.getAllByTitle("Edytuj");
  await userEvent.click(editButtons[0]);

  const frontTextarea = screen.getAllByRole("textbox")[0];
  await userEvent.clear(frontTextarea);
  await userEvent.type(frontTextarea, "Edited question");

  await userEvent.click(screen.getByTitle("Zapisz"));

  // 4. Zatwierd≈∫
  const approveButtons = screen.getAllByTitle("Zatwierd≈∫");
  await userEvent.click(approveButtons[0]);

  // 5. Zapisz wszystkie
  await userEvent.click(screen.getByRole("button", { name: /Zapisz fiszki/i }));

  // Assert
  await waitFor(() => {
    expect(screen.queryByText(/Propozycje fiszek/i)).not.toBeInTheDocument(); // Reset
  });
});
```

---

## üìä Podsumowanie planu

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  PLAN TESTOWANIA - GENERATOR FEATURE                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚úÖ ETAP 1: useGenerator.ts                     27 test√≥w  DONE ‚îÇ
‚îÇ  ‚è≥ ETAP 2: FlashcardProposalCard.tsx          10-12 test√≥w     ‚îÇ
‚îÇ  ‚è≥ ETAP 3: GenerationForm.tsx                  8-10 test√≥w     ‚îÇ
‚îÇ  ‚è≥ ETAP 4: FlashcardProposalList.tsx            6-8 test√≥w     ‚îÇ
‚îÇ  ‚è∏Ô∏è  ETAP 5: Integration Tests (opcja)          2-3 testy      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  üìä SUMA (bez Etapu 5):                        51-57 test√≥w     ‚îÇ
‚îÇ  üìä SUMA (z Etapem 5):                         53-60 test√≥w     ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  ‚è±Ô∏è  Szacowany czas realizacji:                                 ‚îÇ
‚îÇ     ETAP 2: ~45-60 minut                                        ‚îÇ
‚îÇ     ETAP 3: ~30-45 minut                                        ‚îÇ
‚îÇ     ETAP 4: ~30-40 minut                                        ‚îÇ
‚îÇ     ETAP 5: ~30-45 minut (opcjonalny)                           ‚îÇ
‚îÇ  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚îÇ
‚îÇ     RAZEM: 2-3 godziny (bez Etapu 5)                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üéØ Zalecenia implementacyjne

### Kolejno≈õƒá realizacji

1. **ETAP 2** ‚Üí Zawiera najwiƒôcej logiki UI
2. **ETAP 3** ‚Üí Wa≈ºny dla UX (walidacja)
3. **ETAP 4** ‚Üí Prosty, szybki win
4. **ETAP 5** ‚Üí Tylko je≈õli masz czas

### Best practices

- ‚úÖ Testuj zachowanie, nie implementacjƒô
- ‚úÖ U≈ºywaj `userEvent` zamiast `fireEvent`
- ‚úÖ Mockuj tylko to co niezbƒôdne
- ‚úÖ Nazywaj testy opisowo
- ‚úÖ Grupuj logicznie (`describe` blocks)

### Red flags - kiedy przerwaƒá testowanie

- ‚ùå Testy UI ≈ÇamiƒÖ siƒô przy ka≈ºdej zmianie CSS
- ‚ùå Testy sƒÖ d≈Çu≈ºsze ni≈º komponent
- ‚ùå Mockujesz wiƒôcej ni≈º testujesz
- ‚ùå Testy nie dodajƒÖ warto≈õci biznesowej

---

## üìù Instrukcje dla kontynuacji

Gdy bƒôdziesz gotowy kontynuowaƒá:

### Opcja A: Krok po kroku

```bash
# 1. Uruchom watch mode
npm run test:unit -- --watch

# 2. Powiedz: "Kontynuujemy ETAP 2 - Krok 2.1"
```

### Opcja B: Ca≈Çy etap naraz

```bash
# Powiedz: "Zr√≥b ca≈Çy ETAP 2 naraz"
```

### Opcja C: Tylko konkretny test

```bash
# Powiedz: "Napisz test dla walidacji w FlashcardProposalCard"
```

---

## üéâ Podsumowanie

**Masz ju≈º solidnƒÖ podstawƒô** - 27 test√≥w dla logiki biznesowej.

**Pozosta≈Çe etapy sƒÖ opcjonalne**, poniewa≈º:

- Logika biznesowa (ETAP 1) to 80% warto≈õci ‚úÖ
- Komponenty UI ≈Çatwiej testowaƒá E2E
- Czƒôstsze zmiany UI = wy≈ºsze koszty utrzymania test√≥w

**Rekomendacja:**

- MUST DO: ‚úÖ ETAP 1 (DONE)
- SHOULD DO: ETAP 2-3 (je≈õli masz czas)
- NICE TO HAVE: ETAP 4-5 (tylko dla kompletno≈õci)

---

_Dokument utworzony: Pa≈∫dziernik 2025_  
_Status: W trakcie planowania_
